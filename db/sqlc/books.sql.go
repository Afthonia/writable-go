// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: books.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createBook = `-- name: CreateBook :one
INSERT INTO books (
    author_id,
    title,
    subtitle
) VALUES (
    $1, $2, $3
) RETURNING id, 0::bigint as author_id, '' as author, title, COALESCE(subtitle, '')::text as subtitle, created_at
`

type CreateBookParams struct {
	AuthorID int64          `json:"author_id"`
	Title    string         `json:"title"`
	Subtitle sql.NullString `json:"subtitle"`
}

type CreateBookRow struct {
	ID        int64     `json:"id"`
	AuthorID  int64     `json:"author_id"`
	Author    string    `json:"author"`
	Title     string    `json:"title"`
	Subtitle  string    `json:"subtitle"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CreateBook(ctx context.Context, arg CreateBookParams) (CreateBookRow, error) {
	row := q.db.QueryRowContext(ctx, createBook, arg.AuthorID, arg.Title, arg.Subtitle)
	var i CreateBookRow
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Author,
		&i.Title,
		&i.Subtitle,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBook = `-- name: DeleteBook :one
DELETE FROM books
WHERE author_id = $1 AND id = $2
RETURNING id
`

type DeleteBookParams struct {
	AuthorID int64 `json:"author_id"`
	ID       int64 `json:"id"`
}

func (q *Queries) DeleteBook(ctx context.Context, arg DeleteBookParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteBook, arg.AuthorID, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAllBooks = `-- name: GetAllBooks :many

SELECT b.id, u.id as author_id, u.username as author, b.title, COALESCE(b.subtitle, '')::text as subtitle, COALESCE(0, c.number)::bigint as chapters, b.created_at, '' as cover_url FROM books b
INNER JOIN users u ON u.id = b.author_id
LEFT JOIN (SELECT book_id, COUNT(*) as number FROM chapters GROUP BY book_id) c ON c.book_id = b.id
ORDER BY b.title
`

type GetAllBooksRow struct {
	ID        int64     `json:"id"`
	AuthorID  int64     `json:"author_id"`
	Author    string    `json:"author"`
	Title     string    `json:"title"`
	Subtitle  string    `json:"subtitle"`
	Chapters  int64     `json:"chapters"`
	CreatedAt time.Time `json:"created_at"`
	CoverUrl  string    `json:"cover_url"`
}

// -- name: ListBooks :many
// SELECT b.id, u.id as author_id, u.username as author, b.title, COALESCE(”, b.subtitle)::text as subtitle, t.name, COALESCE(0, c.number)::bigint as chapters, b.created_at, ” as cover_url FROM books b
// INNER JOIN users u ON u.id = b.author_id
// LEFT JOIN book_tags bt ON bt.book_id = b.id
// LEFT JOIN tags t ON t.id = bt.tag_id
// LEFT JOIN (SELECT book_id, COUNT(*) as number FROM chapters GROUP BY book_id) c ON c.book_id = b.id
// ORDER BY b.created_at DESC;
func (q *Queries) GetAllBooks(ctx context.Context) ([]GetAllBooksRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBooksRow
	for rows.Next() {
		var i GetAllBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Author,
			&i.Title,
			&i.Subtitle,
			&i.Chapters,
			&i.CreatedAt,
			&i.CoverUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentBooks = `-- name: GetRecentBooks :many
SELECT b.id, u.id as author_id, u.username as author, b.title, COALESCE(b.subtitle, '')::text as subtitle, COALESCE(0, c.number)::bigint as chapters, COALESCE(pb.is_published, false)::bool as is_published, b.created_at, '' as cover_url FROM books b
INNER JOIN users u ON u.id = b.author_id
INNER JOIN published_books pb ON pb.book_id = b.id AND pb.author_id = u.id
LEFT JOIN (SELECT book_id, COUNT(*) as number FROM chapters GROUP BY book_id) c ON c.book_id = b.id
ORDER BY b.created_at DESC 
LIMIT 20
`

type GetRecentBooksRow struct {
	ID          int64     `json:"id"`
	AuthorID    int64     `json:"author_id"`
	Author      string    `json:"author"`
	Title       string    `json:"title"`
	Subtitle    string    `json:"subtitle"`
	Chapters    int64     `json:"chapters"`
	IsPublished bool      `json:"is_published"`
	CreatedAt   time.Time `json:"created_at"`
	CoverUrl    string    `json:"cover_url"`
}

func (q *Queries) GetRecentBooks(ctx context.Context) ([]GetRecentBooksRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentBooksRow
	for rows.Next() {
		var i GetRecentBooksRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Author,
			&i.Title,
			&i.Subtitle,
			&i.Chapters,
			&i.IsPublished,
			&i.CreatedAt,
			&i.CoverUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
